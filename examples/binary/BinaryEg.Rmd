---
title: "Binary Data Example"
author: "Eric Dunipace"
date: "5/7/2019"
output:
  pdf_document: default
  # html_document: default
header-includes: \usepackage{float}
---
<style>
p.caption {
  font-size: 0.9em;
  font-style: italic;
  color: grey;
  margin-right: 10%;
  margin-left: 10%;  
  text-align: justify;
}
</style>
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r data, message= FALSE, warning = FALSE, echo=FALSE}
#### Load packages ####
require(SparsePosterior)
require(ggplot2)
require(CoarsePosteriorSummary)
require(rstan)
require(ggsci)
require(doParallel)
require(xtable)
require(dbarts)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores()-1)

group.names <- c("Selection","Loc./Scale", "Projection")

#### generate data ####
set.seed(555)
n <- 2^10 # 1024
p <- 21 # must be at least 21
nsamp <- 1000
nlambda <- 100
lambda.min.ratio <- 1e-10
gamma <- 1
nthin <- 20
pseudo.observations <- 0
nchains <- 2

#retrieve parameters
target <- get_binary_nonlinear_model()
target$X$corr <- 0.5

X <- target$X$rX(n, target$X$corr, p)
param <- target$rparam() #for non-linear model, not needed
# param <- NULL
# debugonce(target$rdata)
Y.list <- target$rdata(n, X, param, method="modified.friedman")
Y <- Y.list$Y
prob <- Y.list$mu
param <- Y.list$theta

x <- target$X$rX(1, target$X$corr, p)

```
```{r generate new pop, message=FALSE, warning=FALSE, results='hide', echo=FALSE}

Xnew <- matrix(NA, nrow=n, p)
i <- 0
while(i < n) {
  Xnew[i+1,] <- target$X$rX(1, target$X$corr, p)
  if(Xnew[i+1, 6] < 0 & Xnew[i+1, 7] < 0) i <- i + 1
}

dfXnew <- data.frame(Xnew[,-1])
  formula <- formula(paste0("~ .^2 + ", 
                            paste0("I(",colnames(dfXnew),"^2)", collapse=" + ")))
  combinationsNew <- model.matrix(formula, data=dfXnew)

  
# param <- target$rparam() #for non-linear model, not needed
Y.listNew <- target$rdata(n, Xnew, param, method="modified.friedman")
Ynew <- Y.listNew$Y
probNew <- Y.listNew$mu
paramNew <- Y.listNew$theta

```
```{r posterior, echo=FALSE, message=FALSE, warning=FALSE, results="hide"}
hyperparameters_stan <- list(m0 = NULL, scale_intercept = NULL)
hyperparameters_stan$m0 <- 5
hyperparameters_stan$scale_intercept <- 2.5

hyperparameters_bart <- list(k = NULL, power = NULL, base = NULL)
hyperparameters_bart$power <- 0.1
hyperparameters_bart$base <- 0.95
# hyperparameters_bart$power <- 2
# hyperparameters_bart$base <- .25

stan_dir <- "../../exec/Stan"
if(!file.exists("posterior.RData")){
  
  post.bart <- target$rpost(nsamp, X[,-1], Y, hyperparameters_bart, method="bart", nskip = nsamp*nthin,
                            keepevery = nthin, X.test=Xnew[,-1], chains = nchains, 
                            numcut = 100, ntree = 200)
  
  post.gamm <- target$rpost(nsamp, X, Y, hyperparameters_stan, method="gamm", chains = nchains, 
                            X.test = Xnew[,-1])
  
  gammX <- as.matrix(post.gamm$model$x)

  logistic.path <- file.path(stan_dir,"logistic_horseshoe_noQR.stan")
  post.stan <- target$rpost(nsamp, X, Y, hyperparameters_stan, 
                            method="logistic", stan_dir = logistic.path, chains = nchains) 

  dfX <- data.frame(X[,-1])
  formula <- formula(paste0("~ .^2 + ", paste0("I(",colnames(dfX),"^2)", collapse=" + ")))
  combinations <- model.matrix(formula, data=dfX)
  post.stan.full <- target$rpost(nsamp, combinations, Y, hyperparameters_stan, 
                                 method="logistic", stan_dir = logistic.path, chains = nchains)
  
  save(post.bart, post.gamm, post.stan, post.stan.full, combinations, gammX, file="posterior.RData")
} else {
  load("posterior.RData")
}
prob <- c(prob)
mse.best.perform <- data.frame(BART = mean((prob - plogis(t(post.bart$eta)))^2),
   'Simple Logistic' = mean((prob - plogis(t(post.stan$eta)))^2),
   'Logistic with Interactions' = mean((prob - plogis(t(post.stan.full$eta)))^2),
   GAMM = mean((prob - plogis(t(post.gamm$eta)))^2))
rownames(mse.best.perform) <- "MSE"

mse.best.perform_logit <- data.frame(BART = mean((qlogis(prob) - (t(post.bart$eta)))^2),
   'Simple Logistic' = mean((qlogis(prob) - (t(post.stan$eta)))^2),
   'Logistic with Interactions' = mean((qlogis(prob) - (t(post.stan.full$eta)))^2),
   GAMM = mean((qlogis(prob) - (t(post.gamm$eta)))^2))
rownames(mse.best.perform_logit) <- "MSE"
```
```{r method_in_sample, message=FALSE, warning=FALSE, cache=FALSE, echo = FALSE}
# penalty.factor.simple <- 1/colMeans(abs(post.stan$theta))
# penalty.factor.full <- 1/colMeans(abs(post.stan.full$theta))
# penalty.factor.gamm <- 1/colMeans(abs(post.gamm$theta))
penalty.factor.simple <- rep(1, ncol(post.stan$theta))
penalty.factor.full <- rep(1, ncol(post.stan.full$theta))
penalty.factor.gamm <- rep(1, ncol(post.gamm$theta))



if( !file.exists("interact_adapt_bart.rds") ) {
  interaction_adapt_bart <- list(
                 selection = W2L1(X=combinations, Y = post.bart$eta, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 # location.scale = W2L1(X=combinations, Y=post.bart$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1e2, maxit = 1e5, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full,
                 #        method="location.scale"),
                 # projection = W2L1(X=combinations, Y=post.bart$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 mcp = W2L1(X=combinations, Y=post.bart$eta, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e4, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinations, Y=post.bart$eta, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e4, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_bart, "interact_adapt_bart.rds")
} else {
  interaction_adapt_bart <- readRDS( "interact_adapt_bart.rds")
}
if( !file.exists("interact_adapt_gam.rds") ) {
  interaction_adapt_gam <- list(
                 selection = W2L1(X=combinations, Y = post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 # location.scale = W2L1(X=combinations, Y=post.bart$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1e2, maxit = 1e5, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full,
                 #        method="location.scale"),
                 # projection = W2L1(X=combinations, Y=post.gamm$eta, 
                 #        theta=post.stan.full$theta, penalty="mcp.net", alpha=0.99,
                 #        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                 #        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                 #        pseudo_observations = pseudo.observations, display.progress = TRUE,
                 #        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 mcp = W2L1(X=combinations, Y=post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinations, Y=post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_gam, "interact_adapt_gam.rds")
} else {
  interaction_adapt_gam <- readRDS( "interact_adapt_gam.rds")
}
if (!file.exists("simple_adapt_bart.RDS")){
  simple_adapt_bart <- list(
                     selection = W2L1(X=X, Y = post.bart$eta, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     # location.scale = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1e2, maxit = 1e5, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple,
                     #    method="location.scale"),
                     # mcp = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1, maxit = 1e5, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple, method="projection"),
                     mcp = W2L1(X=X, Y=post.bart$eta, 
                        theta=post.stan$theta, penalty="mcp", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=X, Y=post.bart$eta, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_bart, "simple_adapt_bart.RDS")
} else {
  simple_adapt_bart <- readRDS("simple_adapt_bart.RDS")
}

if (!file.exists("simple_adapt_gam.RDS")){
  simple_adapt_gam <- list(
                     selection = W2L1(X=X, Y = post.gamm$eta, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     # location.scale = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1e2, maxit = 1e5, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple,
                     #    method="location.scale"),
                     # projection = W2L1(X=X, Y=post.bart$eta, 
                     #    theta=post.stan$theta, penalty="mcp.net", alpha = 0.5,
                     #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                     #    infimum.maxit=1, maxit = 1e5, gamma = gamma,
                     #    pseudo_observations = pseudo.observations, display.progress = TRUE,
                     #    penalty.factor = penalty.factor.simple, method="projection"),
                     mcp = W2L1(X=X, Y=post.gamm$eta, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=X, Y=post.gamm$eta, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_gam, "simple_adapt_gam.RDS")
} else {
  simple_adapt_gam <- readRDS("simple_adapt_gam.RDS")
}

# if (!file.exists("gamm_adapt.RDS")){
#   gamm_adapt <- list(
#                      selection = W2L1(X=gammX, Y = post.bart$eta, 
#                         theta=post.gamm$theta, penalty="selection.lasso",
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
#                         pseudo_observations = pseudo.observations, 
#                         display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="selection.variable"),
#                      # location.scale = W2L1(X=gammX, Y=post.bart$eta, 
#                      #    theta=post.gamm$theta, penalty="mcp.net", alpha = 0.5,
#                      #    nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                      #    infimum.maxit=1e2, maxit = 1e5, gamma = gamma,
#                      #    pseudo_observations = pseudo.observations, display.progress = TRUE,
#                      #    penalty.factor = penalty.factor.gamm,
#                      #    method="location.scale"),
#                      projection = W2L1(X=gammX, Y=post.bart$eta, 
#                         theta=post.gamm$theta, penalty="mcp.net", alpha = 0.5,
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1, maxit = 1e5, gamma = gamma,
#                         pseudo_observations = pseudo.observations, display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="projection"),
#                      mcp = W2L1(X=gammX, Y=post.bart$eta, 
#                         theta=post.gamm$theta, penalty="mcp", alpha = 0.5,
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1, maxit = 1e5, gamma = gamma,
#                         pseudo_observations = pseudo.observations, display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="projection"),
#                      lasso = W2L1(X=gammX, Y=post.bart$eta, 
#                         theta=post.gamm$theta, penalty="lasso", alpha = 1,
#                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
#                         infimum.maxit=1, maxit = 1e5, gamma = gamma,
#                         pseudo_observations = pseudo.observations, display.progress = TRUE,
#                         penalty.factor = penalty.factor.gamm,
#                         method="projection")
#                 )
#   saveRDS(gamm_adapt, "gamm_adapt.RDS")
# } else {
#   gamm_adapt <- readRDS("gamm_adapt.RDS")
# }
```
```{r w2 distances, echo = FALSE, warning= FALSE, message= FALSE}
names(interaction_adapt_bart) <- 
  names(simple_adapt_bart) <- 
  names(interaction_adapt_gam) <- 
  names(simple_adapt_gam) <-  c("Selection",
                      # "Loc./Scale",
                         # "MCP Net Projection",
                         "MCP Projection",
                         "Lasso Projection")

w2plot <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
w2_file <- "w2plot_bin.rds"

if ( !file.exists(w2_file) ) {
  w2plot$bart$simple <- plot.compare(simple_adapt_bart, post.bart$eta, X, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  # w2plot$interaction <- plot.compare(interaction_adapt, post.bart$eta, 
  #                                    combinations, t(post.stan.full$theta), 
  #                      "w2", c("mean"), parallel = TRUE) 
  w2plot$bart$interaction <- plot.compare(interaction_adapt_bart, post.bart$eta, 
                                     combinations, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot$gam$simple <- plot.compare(simple_adapt_gam, post.bart$eta, X, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  # w2plot$interaction <- plot.compare(interaction_adapt, post.bart$eta, 
  #                                    combinations, t(post.stan.full$theta), 
  #                      "w2", c("mean"), parallel = TRUE) 
  w2plot$gam$interaction <- plot.compare(interaction_adapt_gam, post.bart$eta, 
                                     combinations, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plotData <- lapply(w2plot, function(i) lapply(i, function(j) j$data$mean))
  saveRDS( w2plotData, "w2plot_bin.rds" )
  w2plots <- lapply(w2plot, function(i) lapply(i, function(j) j$plot$mean))
} else {
  w2plotData <- readRDS( w2_file )
  w2plots <- lapply(w2plotData, function(ll) lapply(ll, function(ww) ggplot(ww, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("2-Wasserstein Distance") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0),
                           limits = c(0, max(ww$dist)*1.1))))
}
```
```{r mse distances, message=FALSE, echo=FALSE, warning=FALSE}
names(interaction_adapt_bart) <- 
  names(simple_adapt_bart) <- 
  names(interaction_adapt_gam) <- 
  names(simple_adapt_gam) <-  c("Selection",
                      # "Loc./Scale",
                         # "MCP Net Projection",
                         "MCP Projection",
                         "Lasso Projection")

mseplot <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
mse_file <- "mseplot_bin.rds"
if (!file.exists(mse_file)) {
  mseplot$bart$simple <- plot.compare(simple_adapt_bart, prob, X, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$bart$interaction <- plot.compare(interaction_adapt_bart, prob, 
                                           combinations, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$gam$simple <- plot.compare(simple_adapt_gam, prob, X, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$gam$interaction <- plot.compare(interaction_adapt_gam, prob, 
                                          combinations, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplotData <- lapply(mseplot, function(i) lapply(i, function(j) j$data$mean))
  saveRDS( mseplotData, mse_file )
  mseplots <- lapply(mseplot, function(i) lapply(i, function(j) j$plot$mean))
  
} else {
  mseplotData <- readRDS( mse_file )
  mseplots <- lapply(mseplotData, function(dd) lapply(dd, function(mm) ggplot(mm, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("MSE") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0), 
                           limits = c(0,max(mm$dist)*1.1))))
}
```
```{r generate new pop param, echo = FALSE, message=FALSE, warning=FALSE, results='hide'}
gammXNew <- mgcv::predict.gam(post.gamm$model$jam, newdata=data.frame(Xnew[,-1]), type="lpmatrix")

bartetaNew <- qlogis(pnorm(post.bart$model$yhat.test))
gametaNew <- tcrossprod(gammXNew, post.gamm$theta)
```
```{r method_subset_sample, message=FALSE, warning=FALSE, cache=FALSE, echo = FALSE}
penalty.factor.simple <- rep(1, ncol(post.stan$theta))
penalty.factor.full <- rep(1, ncol(post.stan.full$theta))
penalty.factor.gamm <- rep(1, ncol(post.gamm$theta))

int_new_bart_file <- "interact_adapt_subset_bart.rds" 
if( !file.exists(int_new_bart_file) ) {
  interaction_adapt_subset_bart <- list(
                 selection = W2L1(X=combinationsNew, Y = bartetaNew, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 mcp = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_subset_bart, int_new_bart_file)
} else {
  interaction_adapt_subset_bart <- readRDS( int_new_bart_file )
}

sim_new_bart_file <- "simple_adapt_subset_bart.RDS"
if (!file.exists(sim_new_bart_file)){
  simple_adapt_subset_bart <- list(
                     selection = W2L1(X=Xnew, Y = bartetaNew, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     mcp = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_subset_bart, sim_new_bart_file)
} else {
  simple_adapt_subset_bart <- readRDS(sim_new_bart_file)
}

int_new_gam_file <- "interact_adapt_subset_gam.rds"
if( !file.exists(int_new_gam_file) ) {
  interaction_adapt_subset_gam <- list(
                 selection = W2L1(X=combinationsNew, Y = gametaNew, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="selection.variable"),
                 mcp = W2L1(X=combinationsNew, Y=gametaNew, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinationsNew, Y=gametaNew, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )
  saveRDS(interaction_adapt_subset_gam, int_new_gam_file)
} else {
  interaction_adapt_subset_gam <- readRDS( int_new_gam_file )
}


sim_new_gam_file <- "simple_adapt_subset_gam.RDS"
if (!file.exists(sim_new_gam_file)){
  simple_adapt_subset_gam <- list(
                     selection = W2L1(X=Xnew, Y = gametaNew, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     mcp = W2L1(X=Xnew, Y=gametaNew, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=Xnew, Y=gametaNew, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                )
  saveRDS(simple_adapt_subset_gam, sim_new_gam_file)
} else {
  simple_adapt_subset_gam <- readRDS(sim_new_gam_file)
}

```
```{r w2 distances new, message=FALSE, warning=FALSE, cache=FALSE, echo = FALSE}
names(interaction_adapt_subset_bart) <- 
  names(simple_adapt_subset_bart) <- 
  names(interaction_adapt_subset_gam) <- 
  names(simple_adapt_subset_gam) <-  c("Selection",
                      # "Loc./Scale",
                         # "MCP Net Projection",
                         "MCP Projection",
                         "Lasso Projection")

w2plot_subset <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
w2subset_file <- "w2plot_bin_subset.rds"
if ( !file.exists(w2subset_file) ) {
  w2plot_subset$bart$simple <- plot.compare(simple_adapt_subset_bart, 
                                            bartetaNew, Xnew, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$bart$interaction <- plot.compare(interaction_adapt_subset_bart, 
                                                 bartetaNew, 
                                     combinationsNew, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$gam$simple <- plot.compare(simple_adapt_subset_gam, gametaNew, 
                                           Xnew, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$gam$interaction <- plot.compare(interaction_adapt_subset_gam, gametaNew, 
                                     combinationsNew, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plotData_subset <- lapply(w2plot_subset, function(i) lapply(i, function(j) j$data$mean))
  saveRDS( w2plotData_subset, w2subset_file )
  w2plots_subset <- lapply(w2plot_subset, function(i) lapply(i, function(j) j$plot$mean))
} else {
  w2plotData_subset <- readRDS( w2subset_file )
  w2plots_subset <- lapply(w2plotData_subset, 
                           function(ll) lapply(ll, function(ww) 
       ggplot(ww, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("2-Wasserstein Distance") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0),
                           limits = c(0, max(ww$dist)*1.1))))
}
```
```{r mse distances new, message=FALSE, echo=FALSE, warning=FALSE, echo = FALSE}
names(interaction_adapt_subset_bart) <- 
  names(simple_adapt_subset_bart) <- 
  names(interaction_adapt_subset_gam) <- 
  names(simple_adapt_subset_gam) <-  c("Selection",
                      # "Loc./Scale",
                         # "MCP Net Projection",
                         "MCP Projection",
                         "Lasso Projection")

mseplot_subset <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
mse_subset_file <- "mseplot_bin_subset.rds"
if (!file.exists(mse_subset_file)) {
  mseplot_subset$bart$simple <- plot.compare(simple_adapt_subset_bart, probNew, Xnew, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$bart$interaction <- plot.compare(interaction_adapt_subset_bart, probNew, 
                                           combinationsNew, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$gam$simple <- plot.compare(simple_adapt_subset_gam, probNew, Xnew, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$gam$interaction <- plot.compare(interaction_adapt_subset_gam, probNew, 
                                          combinationsNew, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplotData_subset <- lapply(mseplot_subset, function(i) lapply(i, function(j) j$data$mean))
  saveRDS( mseplotData_subset, mse_subset_file)
  mseplots_subset <- lapply(mseplot_subset, function(i) lapply(i, function(j) j$plot$mean))
  
} else {
  mseplotData_subset <- readRDS(mse_subset_file)
  mseplots_subset <- lapply(mseplotData_subset, 
                            function(dd) lapply(dd, function(mm) 
      ggplot(mm, aes(x=nactive, y=dist, color = groups, group=groups )) +
        geom_line() + scale_color_jama() + labs(color ="Method") +
        xlab("Number of active coefficients") + ylab("MSE") + theme_bw() +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0), 
                           limits = c(0,max(mm$dist)*1.1))))
}
```
## Setup
The method can also be used on binary data. We simulate data as follows. 

### Predictors
We can measure variable importance in a variety of settings. Our first example is in a setting with Normally distributed data. We generate $n = `r n`$ predictor variables, $X$, from a Multivariate Normal,
\[ X_i \sim N(0, \Sigma), \] with $\Sigma_{i,i} = 1$ for all $i$ from 1 to $p = `r p-1`.$ The first 20 dimensions of $X$ are correlated, dimensions 21 to 50 are correlated, and dimensions 51 to 100 are corrlated,  with correlations `r target$X$corr`. Thus, $\Sigma$ is block diagonal.

<!-- ### Parameters -->
<!-- We generate parameters as follows -->
<!-- \[ \beta_{0:5} \sim \text{Unif}(0.1,0.2),\] -->
<!-- \[ \beta_{6:10} \sim \text{Unif}(-0.2,-0.1), \] and -->
<!-- \[ \beta_{11:20} \sim \text{Unif}(0,0.05). \] -->

### Outcome
We sample the outcome from a modified Friedman model:
<!-- cos(2 * x3sq + pi/2) -->
<!--     x3term <- ifelse(2 * x3sq > 3/4 * pi, 1,  costerm) -->
<!-- return(1 * sin(\frac{pi}{8}  x[,1] * x[,2] + pi/2) + 2 * x3term  + tanh(-x[,4]) + 0.25 * x[,5]) -->
\[Y_i \sim \text{Bernoulli}(\nu_i) \] with 
\[\nu_i = \text{logit}^{-1} \left [\sin\left(\frac{\pi}{8}x_{i,1}x_{i,2} + \pi/2 \right) + 2 g(x_{i,6}) + h(x_{i,7}) + \tanh \left(-\frac{\pi}{8} x_{i,11} x_{i,15}^2 \right) \right],\]
where 
\[ g(x) = \left \{ 
\begin{array}{l} 
1 \text{ if } x^2 > 3/8 \pi \\
\cos\left(2 x^2  + \pi/2\right), \text{ otherwise} \\
\end{array} 
\right. \] and
\[h(x) = (2/5 * x^3 - 1/8 * x^2 - 2 * x)*\exp(-x^2/5) \]
<!-- \[\nu_i = \text{logit}^{-1} \left [ .14 \cdot \tanh(X_1^2 \cdot X_3) + .015 \cdot X_4 \cdot X_{15} \cdot X_{16} + 0.0125 \cdot X_2 \cdot X_{12}^3 + .015 \cdot \exp(X_6) + 0.18 \cdot X_2  - 0.7\right].\] -->

```{r data_echo, echo=TRUE, eval=FALSE}
<<data>>
```

## Posterior Estimation
We use 4 posterior distributions:

1. a Bayesian additive regression tree (BART) model,
2. a simple logistic regression with the main effects of $X$,
3. a more complicated logistic regression with the main effects and all second order interactions, and
4. a generalized additive mixed model (GAMM).
<!-- All models are estimated with their software defaults and the logistic regression are estimated with the Finnish horseshoe. -->
```{r mse_table, echo=FALSE, warning=FALSE, results='asis'}
print(xtable(mse.best.perform, digits=3, caption="MSE of the posterior predictive means from true data generating probabilities"), sanitize.colnames.function = function(x) gsub("[.]", " ",x), comment=FALSE)
```
Clearly, the Bayesian Additive Regression Trees model fits best followed by the Generalized Additive Mixed model.

Then we try to adapt our more poorly fitting but more interpretable models to the better fitting models.
```{r method_in_sample print, eval = FALSE}
penalty.factor.simple <- rep(1, ncol(post.stan$theta))
penalty.factor.full <- rep(1, ncol(post.stan.full$theta))
penalty.factor.gamm <- rep(1, ncol(post.gamm$theta))

  interaction_adapt_bart <- list(
                 selection = W2L1(X=combinations, Y = post.bart$eta, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="selection.variable"),
                 mcp = W2L1(X=combinations, Y=post.bart$eta, 
                        theta=post.stan.full$theta, penalty="mcp", 
                        alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e4, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinations, Y=post.bart$eta, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e4, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="projection",tol = 1e-3)
                )
 
  interaction_adapt_gam <- list(
                 selection = W2L1(X=combinations, Y = post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                 mcp = W2L1(X=combinations, Y=post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinations, Y=post.gamm$eta, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.full, method="projection",tol = 1e-3)
                )

  simple_adapt_bart <- list(
                     selection = W2L1(X=X, Y = post.bart$eta, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="selection.variable"),
                     mcp = W2L1(X=X, Y=post.bart$eta, 
                        theta=post.stan$theta, penalty="mcp", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection"),
                     lasso = W2L1(X=X, Y=post.bart$eta, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, method="projection")
                    )
  
  simple_adapt_gam <- list(
                     selection = W2L1(X=X, Y = post.gamm$eta, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="selection.variable"),
                     mcp = W2L1(X=X, Y=post.gamm$eta, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="projection"),
                     lasso = W2L1(X=X, Y=post.gamm$eta, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="projection")
                )
```

Next, we plot the 2-Wasserstein distances between the coarse approximations of the posterior predictive distributions on the logit scale and the full posterior predictive distributions, also on the logit scale, from the better fitting models
```{r w2 distances print, eval = FALSE}
names(interaction_adapt_bart) <- 
  names(simple_adapt_bart) <- 
  names(interaction_adapt_gam) <- 
  names(simple_adapt_gam) <-  c("Selection",
                         "MCP Projection",
                         "Lasso Projection")

w2plot <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))

  w2plot$bart$simple <- plot.compare(simple_adapt_bart, 
                                     post.bart$eta, X, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot$bart$interaction <- plot.compare(interaction_adapt_bart, post.bart$eta, 
                                     combinations, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot$gam$simple <- plot.compare(simple_adapt_gam, 
                                    post.bart$eta, X, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot$gam$interaction <- plot.compare(interaction_adapt_gam, post.bart$eta, 
                                     combinations, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 

  w2plots <- lapply(w2plot, function(i) lapply(i, function(j) j$plot$mean))
}
```

Further, we calculate the mean squared error (MSE) between the posterior predictive means and the true generating probabilities
```{r mse distances print, eval=FALSE}
names(interaction_adapt_bart) <- 
  names(simple_adapt_bart) <- 
  names(interaction_adapt_gam) <- 
  names(simple_adapt_gam) <-  c("Selection",
                         "MCP Projection",
                         "Lasso Projection")

mseplot <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))

  mseplot$bart$simple <- plot.compare(simple_adapt_bart, prob, X, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$bart$interaction <- plot.compare(interaction_adapt_bart, prob, 
                                           combinations, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$gam$simple <- plot.compare(simple_adapt_gam, prob, X, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot$gam$interaction <- plot.compare(interaction_adapt_gam, prob, 
                                          combinations, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplots <- lapply(mseplot, function(i) lapply(i, function(j) j$plot$mean))
```

The we plot the 2-Wasserstein distance and MSE for the BART model
```{r dist_plot_post_simple, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='2-Wasserstein Distance between the posterior linear predictor from the coarsened posterior and the full posterior preditive mean from the Bayesian Additive Regression Trees model after a logistic transformation for the simple logistic regression (left) and the logistic model with all 2-way interactions (right).'}
print(w2plots$bart$simple)
print(w2plots$bart$interaction)
```

```{r dist_plot_post_interact,echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='MSE between the posterior predictive mean from the coarsened posterior trained on the Bayesian Additive Regression Trees model and the true data generating probabilities for the simple logistic regression (left) and the logistic model with all 2-way interactions (right).'}
print(mseplots$bart$simple)
print(mseplots$bart$interaction)
```

and the Generalized Additive Mixed regression model
```{r w2dist_plot_post_gamm, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='2-Wasserstein Distance between the posterior linear predictor from the coarsened posterior and the full posterior preditive mean from the Generalized Additive Mixed regression model after a logistic transformation for the simple logistic regression (left) and the logistic model with all 2-way interactions (right).'}
print(w2plots$gam$simple)
print(w2plots$gam$interaction)
```

```{r msedist_plot_post_gamm, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='MSE between the posterior predictive mean from the coarsened posterior and the true data generating probability for the simple logistic regression (left) and the logistic model with all 2-way interactions (right). .'}
print(mseplots$gam$simple)
print(mseplots$gam$interaction)
```
It appears like the selection variable method works pretty well over all in terms of MSE and occasionally, the projection methods do better.

## Using a subset of data
We may be interested in obtaining a better prediction for a subset of data, or a new population, as from a more interpretable model. That is, maybe we want to adapt our interpretable model to our better predicting model---in this case the BART model. We generate new pseudo data with $X_6 <0$ and $X_7 < 0$
```{r new_echo, eval=FALSE}
<<generate new pop>>
```
and generate new predctions from the BART and GAM models.
```{r generate new pop param print, eval = FALSE}
gammXNew <- mgcv::predict.gam(post.gamm$model$jam, 
                              newdata=data.frame(Xnew[,-1]), type="lpmatrix")

bartetaNew <- post.bart$test$eta
gametaNew <- post.gamm$test$eta
```
For comparison, the predicted MSE of each method is
```{r mse subset print, echo=FALSE, results='asis'}
mse.best.perform_new <- data.frame(BART = mean((probNew - plogis(t(bartetaNew)))^2),
   'Simple Logistic' = mean((probNew - plogis(Xnew %*% t(post.stan$theta)))^2),
   'Logistic with Interactions' = mean((probNew - plogis(combinationsNew %*% t(post.stan.full$theta)))^2),
   GAMM = mean((probNew - plogis(gametaNew))^2))
rownames(mse.best.perform_new) <- "MSE"
print(xtable(mse.best.perform_new, digits=3, caption="MSE from true data generating probabilities for $X_6<0$ and $X_7 < 0$"), sanitize.colnames.function = function(x) gsub("[.]", " ",x), comment=FALSE)
```

Then we can try our procedures again 
```{r method_subset_sample print, eval=FALSE}
penalty.factor.simple <- rep(1, ncol(post.stan$theta))
penalty.factor.full <- rep(1, ncol(post.stan.full$theta))
penalty.factor.gamm <- rep(1, ncol(post.gamm$theta))

  interaction_adapt_subset_bart <- list(
                 selection = W2L1(X=combinationsNew, Y = bartetaNew, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="selection.variable"),
                 mcp = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinationsNew, Y=bartetaNew, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="projection",tol = 1e-3)
                )

  simple_adapt_subset_bart <- list(
                     selection = W2L1(X=Xnew, Y = bartetaNew, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="selection.variable"),
                     mcp = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="projection"),
                     lasso = W2L1(X=Xnew, Y=bartetaNew, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="projection")
                )
  
  interaction_adapt_subset_gam <- list(
                 selection = W2L1(X=combinationsNew, Y = gametaNew, 
                        theta=post.stan.full$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 5e2, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="selection.variable"),
                 mcp = W2L1(X=combinationsNew, Y=gametaNew, 
                        theta=post.stan.full$theta, penalty="mcp", alpha=0.99,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="projection",tol = 1e-3),
                 lasso = W2L1(X=combinationsNew, Y=gametaNew, 
                        theta=post.stan.full$theta, penalty="lasso", alpha=1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.full, 
                        method="projection",tol = 1e-3)
                )
  
  simple_adapt_subset_gam <- list(
                     selection = W2L1(X=Xnew, Y = gametaNew, 
                        theta=post.stan$theta, penalty="selection.lasso",
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1e4, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="selection.variable"),
                     mcp = W2L1(X=Xnew, Y=gametaNew, 
                        theta=post.stan$theta, penalty="mcp", alpha = 0.5,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple,
                        method="projection"),
                     lasso = W2L1(X=Xnew, Y=gametaNew, 
                        theta=post.stan$theta, penalty="lasso", alpha = 1,
                        nlambda = nlambda, lambda.min.ratio = lambda.min.ratio,
                        infimum.maxit=1, maxit = 1e5, gamma = gamma,
                        pseudo_observations = pseudo.observations, 
                        display.progress = TRUE,
                        penalty.factor = penalty.factor.simple, 
                        method="projection")
                )

```

And calculate 2-Wasserstein Distances
```{r w2 distances new print, eval=FALSE}
names(interaction_adapt_subset_bart) <- 
  names(simple_adapt_subset_bart) <- 
  names(interaction_adapt_subset_gam) <- 
  names(simple_adapt_subset_gam) <-  c("Selection",
                         "MCP Projection",
                         "Lasso Projection")

w2plot_subset <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
  w2plot_subset$bart$simple <- plot.compare(simple_adapt_subset_bart, 
                                            bartetaNew, Xnew, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$bart$interaction <- plot.compare(interaction_adapt_subset_bart, 
                                                 bartetaNew, 
                                     combinationsNew, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$gam$simple <- plot.compare(simple_adapt_subset_gam, gametaNew, 
                                           Xnew, t(post.stan$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plot_subset$gam$interaction <- plot.compare(interaction_adapt_subset_gam, gametaNew, 
                                     combinationsNew, t(post.stan.full$theta), 
                       "w2", c("mean"), parallel = TRUE) 
  w2plots_subset <- lapply(w2plot_subset, function(i) lapply(i, function(j) j$plot$mean))

```
and the MSE between the true probabilities and the predicted probabililties from the coarsened posterior
```{r mse distances new print, eval=FALSE}
names(interaction_adapt_subset_bart) <- 
  names(simple_adapt_subset_bart) <- 
  names(interaction_adapt_subset_gam) <- 
  names(simple_adapt_subset_gam) <-  c("Selection",
                         "MCP Projection",
                         "Lasso Projection")

mseplot_subset <- list(bart = list (simple=NULL, interaction = NULL),
               gam = list (simple=NULL, interaction = NULL))
  mseplot_subset$bart$simple <- plot.compare(simple_adapt_subset_bart, 
                                             probNew, Xnew, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$bart$interaction <- plot.compare(interaction_adapt_subset_bart, probNew, 
                                           combinationsNew, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$gam$simple <- plot.compare(simple_adapt_subset_gam, 
                                            probNew, Xnew, t(post.stan$theta),
                        "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplot_subset$gam$interaction <- plot.compare(interaction_adapt_subset_gam, probNew, 
                                          combinationsNew, t(post.stan.full$theta), 
                          "mse", c("mean"), parallel = TRUE, transform = plogis)
  mseplots_subset <- lapply(mseplot_subset, function(i) 
                              lapply(i, function(j) j$plot$mean))
  
```

```{r dist_plot_post_simple_subset, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='2-Wasserstein Distance between the posterior linear predictor from the coarsened posterior and the full posterior preditive mean from the Bayesian Additive Regression Trees model after a logistic transformation for the simple logistic regression (left) and the logistic model with all 2-way interactions (right). Using new data with $X_6<0$ and $X_7 < 0$'}
print(w2plots_subset$bart$simple)
print(w2plots_subset$bart$interaction)
```

```{r msedist_plot_post_simple_subset, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='MSE between the posterior predictive mean from the coarsened posterior trained on the Bayesian Additive Regression Trees model and the true data generating probabilities for the simple logistic regression (left) and the logistic model with all 2-way interactions (right). Using new data with $X_6<0$ and $X_7 < 0$'}
print(mseplots_subset$bart$simple)
print(mseplots_subset$bart$interaction)
```

```{r dist_plot_post_interaction_subset, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='2-Wasserstein Distance between the posterior linear predictor from the coarsened posterior and the full posterior preditive mean from the Generalized Additive Mixed regression model after a logistic transformation for the simple logistic regression (left) and the logistic model with all 2-way interactions (right). Using new data with $X_6<0$ and $X_7 < 0$'}
print(w2plots_subset$gam$simple)
print(w2plots_subset$gam$interaction)
```

```{r msedist_plot_post_interaction_subset, echo=FALSE, message=FALSE, warning=FALSE, fig.height= 4, fig.width=4, out.width="49%", optipng = '-o7', fig.align = "center", fig.show='hold', fig.pos = "H", fig.cap='MSE between the posterior predictive mean from the coarsened posterior trained on the Generalized Additive Mixed regression  model and the true data generating probabilities for the simple logistic regression (left) and the logistic model with all 2-way interactions (right). Using new data with $X_6<0$ and $X_7 < 0$'}
print(mseplots_subset$gam$simple)
print(mseplots_subset$gam$interaction)
```

